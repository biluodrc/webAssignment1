<!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Auto Connect6</title>
<link href="../BlogPostAssets/styles/blogPostStyle.css" rel="stylesheet" type="text/css">
<!--The following script tag downloads a font from the Adobe Edge Web Fonts server for use within the web page. We recommend that you do not modify it.--><script>var __adobewebfontsappname__="dreamweaver"</script><script src="http://use.edgefonts.net/montserrat:n4:default;source-sans-pro:n2:default.js" type="text/javascript"></script>
</head>

<body background="../BlogPostAssets/images/green-wheat-fields-auvers-vincent-van-gogh-1890-0e6db666.jpg" background-size="cover">
<div id="mainwrapper">
  <header> 
    <!--**************************************************************************
    Header starts here. It contains Logo and 3 navigation links. 
    ****************************************************************************-->
    <div id="logo">Biluo‘Blog</div>
    <nav> <a href="home.html" title="Link">Blog</a> <a href="#" title="Link">FilmReview</a> </nav>
  </header>
  <div id="content">
    <section id="mainContent"> 
      <!--************************************************************************
    Main Blog content starts here
    ****************************************************************************-->
	  <section class="passageLinkPart">
		<a href="article_3.html">Auto Connect6</a>
		<hr/>
        <p>很多版代码之后，当前x.y版codebiluo终于可以和我来一局焦灼的对局了！！！</p>
<p>这一次的课设题目是自动六子棋，理解题目之后我就直接投身到论文的海洋，看了一段时间论文之后，初步确定自己先使用<strong>基于“路”的博弈树搜索</strong>，之后会详细讨论论文中出现的几种方法，以及我眼中各个方法之间的优劣。这篇博客主要是叙述（也是自己复习，毕竟我连α-β剪枝都打错了😭）<strong>代码中用到的新知识、论文中涉及的方法以及阅读顺序建议</strong>。</p>
<h4 id="一、简述问题与思路"><a href="#一、简述问题与思路" class="headerlink" title="一、简述问题与思路"></a>一、简述问题与思路</h4><p>六子棋对战是一个棋手双方博弈的过程，最终的目的就是根据当前的棋局确定下一步着法。一般首先想到的是遍历每一种着棋组合，对其评估，然后得到较优的解，这也是一般人下棋的策略；但是高手往往能知道对手的想法，<em>预判对手的着棋，甚至是预判对手的预判</em>。做到这一点，就是通过<strong>博弈树</strong>来实现。</p>
<p>知道了博弈树，就要了解该如何对博弈树进行搜索的问题。博弈树一般使用<strong>极大极小搜索方法</strong>或者是<strong>α-β搜索方法</strong>，后者是对前者的优化。我在编写代码时先编写了前者，到后者的改变实际只有四行代码。</p>
<p>博弈树中的每一个节点，对应了一个棋局，想要完成博弈，人类是通过对棋局进行感性的分析，而机器则是需要得到一个理性的结果，这个理性的结果就是对棋局的<strong>评估值</strong>，由<strong>评估函数</strong>得到。</p>
<p>想要评估棋局，最重要的是确定通过怎样的方式的到棋局的特征。在六子棋中，主要有<strong>基于“路”</strong>和<strong>基于“连珠”</strong>两种方式，我对二者的评价是：前者代码编写更容易，但只是得到了局部棋局的特征；后者分析棋局更加全面，与前者博弈时或许胜率会更高。所以我使用了基于“路”的方法😂。</p>
<p>以上加粗字，是截至4.8，connect6程序所使用的基本方法，下文中将对这些新知识进行介绍。</p>
<h4 id="二、评估函数"><a href="#二、评估函数" class="headerlink" title="二、评估函数"></a>二、评估函数</h4><p>不同的棋局有着不一样的特征，我们需要通过分析棋局的特征，确定当前棋局对自己的有利程度，以及着棋之后棋局对自己的有利程度，从而得出该如何着棋。人类感性的评价计算机无法实现，我们需要做的是将感性的认识转换为理性的分析，从而评估一个棋局。</p>
<p>相关文献中从两个角度分析棋局，“路”与“连珠”，两个角度各有优劣，下面进行介绍，</p>
<h5 id="（一）基于”路“的评估函数"><a href="#（一）基于”路“的评估函数" class="headerlink" title="（一）基于”路“的评估函数"></a>（一）基于”路“的评估函数</h5><p>所谓“路”就是指在棋盘上存在连续6个可能连成一线的点位[1]。也就是说，在水平、竖直、斜45°、斜135°的某个方向上，连续六个交叉点中黑子/白子的棋形称为“路”。</p>
<p>关于“路”的定义并不是很清晰，转化为代码的实现会更容易理解，从某一个交叉点开始，向四个个方向分别遍历六个交叉点（包括起点），记录黑子与白子的个数为B与W，分类讨论B和W的大小：如B、W都不为0，即两种棋子在这六个交叉点中同时出现，则将这一路定义为空路；如B、W都为0，即六个交叉点中没有任意一种棋子，则将这一路定义为空路；如B、W中不为0的一方的棋子数目为S，颜色为C，则将这一路定义为C S路，如白三路，黑四路。</p>
<p>根据“路”的定义，分析棋局可以知道，水平、竖直方向上共有19·(19-5)条路，斜45°、斜135°方向上共有(19-5)·(19-5)条路，也就是说六子棋19x19交叉点棋局进行全局扫描的总路数是924。这个数据在之后介绍局面的局部扫描时还会提到。</p>
<p>路的颜色为黑/白/空，路的数目为1、…、6，<strong>参考文献[2]中给出了基于“路”的评估函数：</strong><br>$$<br>Score=Σ<em>{i=1}^6(MyRoadNum[i]*RoadScore[i])-Σ</em>{i=1}^6(OpRoadNum[i]*RoadScore[i])<br>$$<br>Score为对当前局面的评估值，MyRoadNum[i]为棋局中C为执棋方棋子颜色，S=i的路的总数，OpRoadNum[i]为棋局中C为对手棋子颜色，S=i的路的总数，RoadScore[i]为S=i的路所对应的在棋局中的权重。下面分析权重系数以及评估函数：</p>
<p>不同的路对棋局的影响是不同的，易知，S越大，C S路对棋局的影响越大。为了在评估函数中表现出这一点，使用的方法就是S越大，对应的权重系数越大，通过经验得到初步的权重系数：<strong>{1,5,10,25,35,10000}</strong>。权重系数的作用就是表现对应种类的路对棋局的影响。</p>
<p>分析评估函数之前，首先假定，<strong>对于当前执棋方，评估值Score越大，表明当前棋局对自己更有利。</strong>在此基础上，评估函数就可以用下面的一段话来理解：<strong>执棋方颜色的路越多、对应权重系数大的路越多，则评估函数中前一个求和项的数值更大，表明棋局对执棋方更加有利；对手方颜色的路越少、对应权重系数大的路越少，则评估函数中后一个求和项的数值更大，表明棋局对执棋方更加不利。</strong>（最开始阅读论文的时候我并不理解这个评估函数，一直想不通为什么对手方的权重系数也是递增的，直到有一天下午灵光一现，理解了这个评估函数的意义）</p>
<h5 id="（二）基于”连珠“的评估函数"><a href="#（二）基于”连珠“的评估函数" class="headerlink" title="（二）基于”连珠“的评估函数"></a>（二）基于”连珠“的评估函数</h5><p>在一个区间中,所有的同色的交叉点构成的序列,称为连珠。连珠是与一般人思考方式相近的一种棋局特征的表达，比如在五子棋中有活三、眠3等术语，对应了不同的着棋策略。五子棋中的策略可以类比到六子棋，比如对于着棋方的活四或活五，应采取直接落子在活四两端；对手方的活三，倾向于在其一端落下一子，将其转换为眠三，这样就算对手想要继续在这一连珠做文章，最多也只能达到眠5……</p>
<p>连珠可以表现某一棋形的连通程度、对手的威胁以及棋形的进攻防守能力，基于这三方面，可以将连珠进行分类。除此之外，连珠还有很重要的一点就是不同种类连珠之间的演化，比如上面举出的眠三落两子变为眠五，活四落两子可以冲六等等，记录他们之间的演化可以加快对局面的分析，从而加速搜索。</p>
<p><strong>参考文献[3]</strong>详细介绍了基于连珠模式的六子棋博弈系统，其中提到连珠形状共有1048512种，通过上面三种方面可以将连珠分成12种类型，并通过一个经过论证的hash函数，可以完成连珠形状搜索的加速。这篇论文中还涉及很多本文中没有提到的搜索方法以及一些优化策略，十分建议阅读，但是伴随的问题是论文涉及的技术太多，想要短时间复现代码实在困难，所以在部分阅读之后我没有选择基于“连珠”的方法。</p>
<p>基于”连珠“的评估函数也可以使用与基于“路”的评估函数相同的方法，即<strong>评估值等于不同类型连珠的加权和</strong>。但是参考文献[3]中先从三个方面对局面进行评估：首先是<strong>开局阶段对于静态位置的评估</strong>，这一点是根据经验，<em>先脱离双方激烈拼杀区域者将处于劣势，</em>故<strong>设置第一枚落子一定在天元，同时添加一个位置偏移表，来保证棋局以中心开局</strong>；其次考虑不同连珠的权重，还是使用类似“路”估值函数的加权和形式，但是作者使用了<strong>先对第一个落子进行评估，然后根据第一个落子下落后的局面评估值，指导第二个落子的下落</strong>，其他论文都是采用两枚棋子落下之后的局面进行评估，下文α-β搜索方法中会说明这么做的意义；最后一点是动态因素的估值，这部分在我看来是个性化的判断，<del>比如说本来已经要赢了，但是偏偏不下在终结棋局的位置，反而落子到其他位置，略略略</del>，其实是我并不太理解动态因素的估值。同时论文中还提到基于交叉点的评估，这一步是<strong>将可选点进行桶排序，每一次博弈从有序着棋点序列中选择着棋点，</strong>这个方法可以对搜索进行极大的优化，我可能会在之后的优化中使用这个方法。</p>
<h5 id="（三）基于“路”的局部扫描方式"><a href="#（三）基于“路”的局部扫描方式" class="headerlink" title="（三）基于“路”的局部扫描方式"></a>（三）基于“路”的局部扫描方式</h5><p>上文提到六子棋19x19交叉点棋局进行全局扫描的总路数是924，乍一看这并不是一个很大的数字，因为总共访问的交叉点个数也就是924(路)·4(方向数)·6(每个方向访问的交叉点数目)=22176个交叉点。但是当考虑到其庞大的子节点个数的时候，这个数字就变得非常恐怖。<strong>参考文献<a href="">[4]</a></strong>就提出了基于“路”的局部扫描方式，这个方法是从当前局面出发，对不同的着棋点进行模拟落子，在新的局面中，模拟落子只会影响它四个方向上的各条路。假设父节点原本的评估值为Vtotal，受影响的路原本的评估值为Vbefor，受影响的路落子后的评估值为Vafter，落子后局面的评估值Vtotal’也就是：<br>$$<br>V_{total}’=V_{total}-V_{befor}+V_{after}<br>$$<br>全局扫描不难，按照定义逐个方向扫描即可，只需要注意不要重复计算同一个路即可。</p>
<h4 id="三、博弈树及其搜索方法"><a href="#三、博弈树及其搜索方法" class="headerlink" title="三、博弈树及其搜索方法"></a>三、博弈树及其搜索方法</h4><h5 id="（一）博弈树"><a href="#（一）博弈树" class="headerlink" title="（一）博弈树"></a>（一）博弈树</h5><p>最开始在论文中看到博弈树，我想起之前学过的决策树，这两者之间的关系可以用下面这段话来表示：</p>
<blockquote>
<p>决策树适用于一个人面临各种选择时的描述分析，而博弈树则适用于多个参与者在一场策略博弈中的决策次序的描述分析。</p>
</blockquote>
<p>完整的博弈树，考虑到从开局落下第一个子，到最终无论是和局，还是输赢的所有过程，想象这样一个画面，确定第一个落子为天元，开局局面为根节点，之后的落子为任意的两个交叉点，第二层就有大约19^4个节点，这仅仅是第二层，第二层每个节点之下又会有大约19^4个节点，<strong>完整的博弈树，是无法想象的庞大</strong>（当然只是笼统的统计）。所以实际编程时，我们实际是生成一颗搜索树——博弈树的子树。（但下文有时仍然使用博弈树，但需要知道，下文的博弈树仅仅是完整博弈树的一个小小子树）</p>
<p>博弈树中用树的各层来表示对弈双方：<strong>第一层为初始局面，表示着棋方，第二层也就是对手，以此类推，也就是奇数层代表着棋方，偶数层代表对手。</strong>树的节点来表示各种棋局，节点之间的连线可以想象成着棋的动作。最终目标是着棋方选择从初始局面（第一层）转换到第二层中的哪一个局面；为更好的达到这一个目标，就需要通过分析自己落子之后，对手会如何落子（从第二层到第三层）；更进一步，还要分析在对手落子之后，我还会怎么做（第三层到第四层）；以此类推，这样的过程有些像<em>博弈论中的共同知识</em>——我知道，你知道，我知道你知道，你知道我知道你知道……</p>
<p>对于着棋方而言，希望能放大自己的优势，或者是缩小自己的劣势；对于对手而言，希望能缩小着棋方的优势，后者是放大着棋方的优势，这些都是通过对比不同落子的局面评估值之间的关系来实现的。<strong>着棋方（奇数层）遍历自己的各种着棋可能，计算他们的评估值，并将自己的评估值更新为子节点评估值中的最大值，故称奇数层为MAX层；而对手（偶数层）也是遍历自己的各种着棋可能，计算他们的评估值，并将自己的评估值更新为子节点评估值中的最小值，称为MIN层。</strong></p>
<p>通过上面这个概念，也就引出了博弈树的一种搜索方法——极大极小搜索。</p>
<h5 id="（二）极大极小搜索"><a href="#（二）极大极小搜索" class="headerlink" title="（二）极大极小搜索"></a>（二）极大极小搜索</h5><p>极大极小搜索的过程类似于深搜，只不过前者给每一层节点添加了一个MAX/MIN的属性，根据这个属性决定自己节点的值（除了叶节点）。具体的过程如下：</p>
<p>对一颗树进行<strong>深搜</strong>，<strong>叶节点的值也就是原本节点中对应的数；非叶节点的值，是根据自己的MAX/MIN属性，选择其子节点中最大/最小的数。</strong></p>
<p>通过过程图示会更好理解这个极大极小搜索：</p>
<p>这是一个已经搜索完成的搜索树，其中矩形节点表示MAX节点，椭圆形节点表示MIN节点。</p>
<p><img src="https://i.loli.net/2020/04/08/viwMdtOcmqruNnj.png" alt="image-20200408131047736.png"></p>
<p>搜索的过程可以表现为</p>
<p><img src="https://i.loli.net/2020/04/08/ovb3VkGd58PwrU7.png" alt="image.png"></p>
<h5 id="（二）α-β剪枝"><a href="#（二）α-β剪枝" class="headerlink" title="（二）α-β剪枝"></a>（二）α-β剪枝</h5><p>α-β剪枝是对极大极小搜索的优化，优化的效果十分明显。α-β剪枝分为α剪枝和β剪枝：</p>
<h6 id="1、α剪枝"><a href="#1、α剪枝" class="headerlink" title="1、α剪枝"></a>1、α剪枝</h6><p><strong>α剪枝是基于根节点为MAX节点，对第三层节点进行剪枝</strong>，α值保存了已被搜索的第二层节点中目前的最大值，即局部搜索最优结果。初始化α值为-∞，搜索时不断更新，当第二层某个节点的子节点评估值比α值小时，那么就没有必要对第二层的这个节点剩下的子节点进行搜索，因为搜索的结果无论如何不会超过当前的子节点评估值。</p>
<p><img src="https://i.loli.net/2020/04/08/PGKVAnJdBqDUIgM.png" alt="image.png"></p>
<h6 id="2、β剪枝"><a href="#2、β剪枝" class="headerlink" title="2、β剪枝"></a>2、β剪枝</h6><p><strong>β剪枝是基于根节点为MIN节点，对第三层节点进行剪枝</strong>，β值保存了已被搜索的第二层节点中目前的最小值，即局部搜索最差结果。初始化β值为+∞，搜索时不断更新，当第二层某个节点的子节点评估值比β值大时，那么就没有必要对第二层的这个节点剩下的子节点进行搜索，因为搜索的结果无论如何不会小于当前的子节点评估值。</p>
<p>需要注意的是，<strong>剪枝并不是只能发生在这样的只有三层的树中，实际上对于搜索树中每一个三层的子树都可以完成对第三层（其实也是对第二层）的剪枝</strong>。</p>
<h5 id="（三）剪枝的效率问题"><a href="#（三）剪枝的效率问题" class="headerlink" title="（三）剪枝的效率问题"></a>（三）剪枝的效率问题</h5><p>回到（一）中给定的搜索树，手动跑一遍α剪枝，可以发现根本就没有剪枝，这是为什么呢？剪枝是出现过的对根节点较优的值，对之后出现的不如该值优越的子节点的剪枝，所以<strong>将能产生较优结果的节点（或者说是着棋方式）放在前面，优先遍历，才能更好的对之后的节点进行剪枝。</strong></p>
<h4 id="四、未使用的方法"><a href="#四、未使用的方法" class="headerlink" title="四、未使用的方法"></a>四、未使用的方法</h4><h5 id="（一）同型表"><a href="#（一）同型表" class="headerlink" title="（一）同型表"></a>（一）同型表</h5><p>评估函数是对局面进行评估，落子的顺序对其并没有影响，搜索时，可能会产生已经搜索过的子节点，这时可以直接将该子节点连到当前父节点上。这个方法是搜索加速的一种方法。</p>
<h5 id="（二）开局库"><a href="#（二）开局库" class="headerlink" title="（二）开局库"></a>（二）开局库</h5><p>参考文献[3]中指出，在国际象棋、中国象棋、西洋跳棋中,其计算机程序几乎都采用了开局库。事实证明,开局库的存在大大提高了程序的对弈水平。然而不同的棋类中,开局库的重要程度也有所不同。在六子棋中,由于广泛地存在着决定胜负的迫着,所以开局很重要,因为开局时的“一着错”可能马上就导致了“满盘输”。文献中采用”枚举+迫着搜索“的方法，生成开局库。之后可能会添加这个方法，待续。</p>
<h5 id="（三）迭代加深搜索"><a href="#（三）迭代加深搜索" class="headerlink" title="（三）迭代加深搜索"></a>（三）迭代加深搜索</h5><p><del>这也是深搜的一种，与深搜的主要区别是</del></p>
<p>这个算法理解不够深，但使用它的原因是开局时棋子太少，没必要进行太深的搜索，所以先使用较浅的搜索，并且还可以对之后的搜索有”历史启发“。</p>
<h5 id="（四）双评价参数评估函数"><a href="#（四）双评价参数评估函数" class="headerlink" title="（四）双评价参数评估函数"></a>（四）双评价参数评估函数</h5><p>这个方法是[2]中提到的，除了上文中所说的评价函数之外，还引入一个阈值，用于区别当前的局面对对手更优，还是对自己更优，并且对手与自己的路的权值不同。局面对自己更优时，己方路的权值相对大一些；局面对地方更优时，对方路的权值相对大一些。</p>
<h4 id="五、优化"><a href="#五、优化" class="headerlink" title="五、优化"></a>五、优化</h4><p>添加的优化方式，是进行<strong>候选着棋点的排序，</strong>用以增强α-β剪枝的效率。</p>
<p>这一点很多论文中步骤都有，但没有找到特别详细的说明，编写代码的时候忽然想到将简单的连珠模式判断加入候选点的排序中，具体步骤如下：</p>
<p>（1）生成候选着棋点对序列；</p>
<p>（2）以着棋点为中心向两边扩展，并保存端点两侧交叉点颜色（对手颜色或者是空）；</p>
<p>（3）如为死棋（两侧都为对手颜色），直接继续遍历其他方向；之后将连珠大致分为活/眠2/3/4/5以及killer6，并赋予一定权重{1，2，3，4，5，6，7，8，9，10，100}；</p>
<p>（4）根据候选点周围连珠类型的加权和对候选点序列进行排序；</p>
<h4 id="六、参考文献"><a href="#六、参考文献" class="headerlink" title="六、参考文献"></a>六、参考文献</h4><p>[1]闵文杰. 六子棋计算机博弈关键技术研究[D].重庆交通大学,2010.</p>
<p>[2]齐祎霏. 六子棋中基于路的双评价参数评估函数的研究与应用[D].北京工业大学,2018.</p>
<p>[3]徐长明. 基于连珠模式的六子棋机器博弈关键技术研究[D].东北大学,2010.</p>
<p>[4]李学俊,王小龙,吴蕾,刘慧婷.六子棋中基于局部“路”扫描方式的博弈树生成算法[J].智能系统学报,2015,10(02):267-272.</p>
<p>如果使用连珠模式的机器博弈，那么阅读[3]即可，再辅助搜索相关概念，有时一些博客里的的讲解更加清晰，毕竟论文还是有很多复杂的证明……</p>
<p>如果使用路模式的机器博弈，可以先认真阅读[4]，这样对整体的方法会有一个了解；然后[2]引入了一些新的方法，用于优化系统；最后[1]和[3]都是非常详细的介绍了相关算法和一些启发式方法。</p>
      </section>
<div id="bannerImage"></div>
</section>
    <section id="sidebar"> 
      <!--************************************************************************
    Sidebar starts here. It contains a searchbox, sample ad image and 6 links
    ****************************************************************************-->
      
      <div id="adimage"><img src="../BlogPostAssets/images/HeadSculpture.jpg" alt=""/></div>
	  <aside id="authorInfo"> 
        <!-- The author information is contained here -->
        <h2 align="center">BiLuo</h2>
      </aside>
    </section>
  </div>
</div>  
<footer>
	<p align="center">There is nothing permanent except change!</p>
	<p align="center">————Heracleitus</p>
</footer>

</body>
</html>
